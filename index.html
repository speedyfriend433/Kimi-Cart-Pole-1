<!DOCTYPE html>
<html>
<head>
    <title>3-Pole Cartpole Simulation</title>
    <style>
        canvas { border: 1px solid black; }
    </style>

        canvas { border: 1px solid black; }
    </style
        canvas { border: 1px solid black; }
   </head>
<body>
    <canvas id="canvas" width="500" height="300"></canvas>
    <script>
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaledL, 'red');
            drawPole(x, poleBaseY, theta2, scaledL, 'green');
            drawPole(x, poleBaseY, theta3, scaledL, 'yellow');
        }

        // Animation loop
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaledL, 'red');
            drawPole(x, poleBaseY, theta2, scaledL, 'green');
            drawPole(x, poleBaseY, theta3, scaledL, 'yellow');
        }

        // Animation loop
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaledL, 'red');
            drawPole(x, poleBaseY, theta2, scaledL, 'green');
            drawPole(x, poleBaseY, theta3, scaledL, 'yellow');
        }

        // Animation loop
        function animate() {
           
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaledL, 'red');
            drawPole(x, poleBaseY, theta2, scaledL, 'green');
            drawPole(x, poleBaseY, theta3, scaledL, 'yellow');
        }

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaledL, 'red');
            drawPole(x, poleBaseY, theta2, scaledL, 'green');
            drawPole(x, poleBaseY, theta3, scaledL, 'yellow
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaledL, 'red');
            drawPole(x, poleBaseY, theta2, scaledL, 'green');
            drawPole(x, poleBase
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaledL, 'red');
            drawPole(x, poleBaseY, theta2, scaledL
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaledL, 'red');
            drawPole(x, pole
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x, poleBaseY, theta1, scaled
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawPole(x
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each pole with different colors
            drawP
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBaseY = HEIGHT - 60;

            // Draw each
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawCart();

            const poleBase
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH, HEIGHT);
           
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
            context.clearRect(0, 0, WIDTH,
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            updatePhysics();
            
           
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

        function draw() {
            update
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX, endY);
            context.stroke();
        }

       
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, baseY);
            context.lineTo(endX
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(baseX, base
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
            context.strokeStyle = color;
            context.moveTo(base
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 2;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length;
            context.beginPath();
            context.lineWidth = 
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY = baseY - Math.cos(theta) * length
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin(theta) * length;
            const endY
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
            const endX = baseX + Math.sin
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX, baseY, theta, length, color) {
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function drawPole(baseX,
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        }

        function
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cartY, 50, 60);
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX, cart
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle = "blue";
            context.fillRect(cartX
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY = HEIGHT - 60;
            context.fillStyle =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
            const cartY =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX = x - 25;
           
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function drawCart() {
            const cartX =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH) x = WIDTH;
        }

        function
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x > WIDTH)
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x = 0;
            if (x >
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0) x =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
            if (x < 0)
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v * dt;
           
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0, v)); // Clamp velocity
            x += v
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.0, Math.max(-8.0,
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(8.
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration * dt;
            v = Math.min(
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
            v += acceleration *
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update cart velocity and position
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

            // Update
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta3));

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI / 4, Math.max(-Math.PI
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math.PI /
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3 = Math.min(Math
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta2));
            theta3
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-Math.PI / 
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 4, Math.max(-
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta2 = Math.min(Math.PI / 
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
            theta
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, theta1));
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max(-Math.PI / 4
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math.PI / 4, Math.max
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 = Math.min(Math
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip angles to prevent large swings
            theta1 =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

            // Clip
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta3 += omega3 * dt;

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
            theta
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0, omega3));
           
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-21.0,
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(21.0, Math.max(-
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math.min(
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 = Math
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3 += alpha3 * dt;
            omega3 =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2 * dt;

            omega3
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta2 += omega2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.0, omega2));
            theta
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-21.
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0, Math.max(-
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 = Math.min(21.0,
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
            omega2 =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 += alpha2 * dt;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2 +=
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

            omega2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 += omega1 * dt;

           
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta1 +=
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); // Velocity clamping
            theta
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1)); //
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0, omega1
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-21.0,
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21.0, Math.max(-2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(21
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1 = Math.min(2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
            omega1
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1 += alpha1 * dt
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
            omega1
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular velocities and angles
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

            // Update angular
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin(theta3));

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g * Math.sin
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos(theta3) - g *
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration * Math.cos
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (acceleration
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 * L)) * (
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 / (2 *
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3 /
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3 = (3
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2));
            const alpha3
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin(theta2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2) - g * Math.sin
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration * Math.cos(theta2)
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) * (acceleration *
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2 * L)) *
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 / (2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 = (3 /
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1));
            const alpha2 =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math.sin(theta1
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) - g * Math
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos(theta1) -
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration * Math.cos
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (acceleration *
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 * L)) * (accel
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (2 *
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (3 / (
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const alpha1 = (
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for each pole
            const
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration for
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            // Angular acceleration
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const acceleration = force / M;

            //
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControlForce();
            const
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const force = calculateControl
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
            const
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force and cart acceleration
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate the control force
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
            // Calculate
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics() {
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function updatePhysics()
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega3);
        }

        function
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega2 + omega
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (omega1 + omega
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) + kd * (
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta3) +
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (theta1 + theta2 + theta
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp * (
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for each pole
            return kp
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity) terms for
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and derivative (velocity)
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of proportional (angle) and
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum of
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
            // Sum
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        function calculateControlForce() {
           
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

       
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (negative for opposing motion)

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Derivative gain (
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2000; // Der
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd = -2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
        const kd =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proportional gain
       
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Proport
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000; // Pro
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp = 5000
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const kp
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller gains
        const
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        // Controller
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 = 0;

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega3 =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega2 = 0;
        let omega
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        let omega
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; // Angular velocities
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0; //
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 = 0
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega1 =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        let omega
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 20;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI / 2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI /
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 = Math.PI
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 20;
        let theta3 =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math.PI / 
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2 = Math
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let theta2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        let
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted)
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly tilted
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (slightly
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial angles (
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI / 20; // Initial
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI /
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1 = Math.PI
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta1
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        let theta
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart velocity
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0; // Cart
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 0
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v = 
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initially centered)
        let v
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position (initial
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; // Cart position
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2; //
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH / 2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x = WIDTH /
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
        let x
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization

        // State variables
       
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for visualization
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled length for
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // Scaled
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; // S
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50; //
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 50
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L * 5
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL = L *
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; // Time step
        const scaledL
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02; //
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.02;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0.0
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 0
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt = 
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const dt
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
       
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g = 9.81; // Gravity
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const g =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole length
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0; // Pole
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.0;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1.
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 1
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L = 
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const L =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
       
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1; // Pole mass
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1;
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 0.1
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart mass
        const m = 
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; // Cart
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0; //
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.0
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1.
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M = 1
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const M
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
       
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // Simulation constants
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const HEIGHT
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width;
        const
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH = canvas.width
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH =
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const WIDTH
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
       
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2d");
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("2
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("
        const canvas = document.getElementById("canvas");
        const context = canvas
        const canvas = document.getElementById("canvas");
        const context</body>
</html>
